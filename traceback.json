[[{"content":"# Instructions\nGiven paired input/output grids, rigorously solve the puzzle to find the common deterministic transformation rule and implement in Python DSL. Each grid is a rectangular matrix of integers 0-9 representing colors: black(0), blue(1), red(2), green(3), yellow(4), grey(5), pink(6), orange(7), purple(8), brown(9). Grids shown both as ASCII matrices for convenience.\n\nMust resolve every ambiguity before coding. If examples show color changes, determine exact conditions controlling output color. If shapes move/transform, determine precise rules for movement/transformation. Analyze all examples methodically to resolve uncertainties through step-by-step reasoning.\nTransformation rules often have multiple components or exceptions. Main rule might be \"replace pattern X with color Y\" but exceptions like \"unless condition Z\". Rules can depend on shape sizes, relative positions, logical operations between subgrids, directional movements until collision, or complex pattern matching. Must identify ALL components and exceptions.\n\nWrite reasoning inside <think></think> tags. Break complex problems into smaller parts. Reason step-by-step with clear sub-conclusions. Avoid large logical leaps. Continue reasoning until transformation rule is completely understood and unambiguous.\n\nImplement as Python function solve(I: Grid) -> Grid where Grid = tuple[tuple[int]]. Function must work for any valid input matching example properties. Write only the solve function in ```py code blocks, no tests.\n\nExample rule complexity: \"Fill black holes in grey grid with colors based on hole size (1=pink, 2=blue, 3=red)\" or \"Move red shape toward purple shape until collision\" or \"AND two 3x3 subgrids separated by grey line, output red where both had blue\". Actual rule will differ but demonstrates expected complexity/precision level.\n\n# DSL\n\nThe Domain-Specific Language (dsl) for solving the grids have these type and functinal primitives. Use the DSL mainly, and external libraries only if stuck.\nAssume all DSL is already imported as a top-level module, do not reimport or redefine the DSL. Do not explain after an answer.\n```py\nfrom typing import List, Union, Tuple, Any, Container, Callable, FrozenSet, Iterable\n\nBoolean = bool\nInteger = int\nIntegerTuple = Tuple[Integer, Integer]\nNumerical = Union[Integer, IntegerTuple]\nIntegerSet = FrozenSet[Integer]\nGrid = Tuple[Tuple[Integer]]\nCell = Tuple[Integer, IntegerTuple]\nObject = FrozenSet[Cell]\nObjects = FrozenSet[Object]\nIndices = FrozenSet[IntegerTuple]\nIndicesSet = FrozenSet[Indices]\nPatch = Union[Object, Indices]\nElement = Union[Object, Grid]\nPiece = Union[Grid, Patch]\nTupleTuple = Tuple[Tuple]\nContainerContainer = Container[Container]\nShape = IntegerTuple\n\nF = False\nT = True\n\nZERO = 0\nONE = 1\nTWO = 2\nTHREE = 3\nFOUR = 4\nFIVE = 5\nSIX = 6\nSEVEN = 7\nEIGHT = 8\nNINE = 9\nTEN = 10\n\nNEG_ONE = -1\nNEG_TWO = -2\n\nDOWN = (1, 0)\nRIGHT = (0, 1)\nUP = (-1, 0)\nLEFT = (0, -1)\n\nORIGIN = (0, 0)\nUNITY = (1, 1)\nNEG_UNITY = (-1, -1)\nUP_RIGHT = (-1, 1)\nDOWN_LEFT = (1, -1)\n\nZERO_BY_TWO = (0, 2)\nTWO_BY_ZERO = (2, 0)\nTWO_BY_TWO = (2, 2)\nTHREE_BY_THREE = (3, 3)\n\n\ndef identity(x: Any) -> Any:\n    \"\"\"identity function\"\"\"\ndef add(a: Numerical, b: Numerical) -> Numerical:\n    \"\"\"addition\"\"\"\ndef subtract(a: Numerical, b: Numerical) -> Numerical:\n    \"\"\"subtraction\"\"\"\ndef multiply(a: Numerical, b: Numerical) -> Numerical:\n    \"\"\"multiplication\"\"\"\ndef divide(a: Numerical, b: Numerical) -> Numerical:\n    \"\"\"floor division\"\"\"\ndef invert(n: Numerical) -> Numerical:\n    \"\"\"inversion with respect to addition\"\"\"\ndef even(n: Integer) -> Boolean:\n    \"\"\"evenness\"\"\"\ndef double(n: Numerical) -> Numerical:\n    \"\"\"scaling by two\"\"\"\ndef halve(n: Numerical) -> Numerical:\n    \"\"\"scaling by one half\"\"\"\ndef flip(b: Boolean) -> Boolean:\n    \"\"\"logical not\"\"\"\ndef equality(a: Any, b: Any) -> Boolean:\n    \"\"\"equality\"\"\"\ndef contained(value: Any, container: Container) -> Boolean:\n    \"\"\"element of\"\"\"\ndef combine(a: Container, b: Container) -> Container:\n    \"\"\"union\"\"\"\ndef intersection(a: FrozenSet, b: FrozenSet) -> FrozenSet:\n    \"\"\"returns the intersection of two containers\"\"\"\ndef difference(a: FrozenSet, b: FrozenSet) -> FrozenSet:\n    \"\"\"set difference\"\"\"\ndef dedupe(tup: Tuple) -> Tuple:\n    \"\"\"remove duplicates\"\"\"\ndef order(container: Container, compfunc: Callable) -> Tuple:\n    \"\"\"order container by custom key\"\"\"\ndef repeat(item: Any, num: Integer) -> Tuple:\n    \"\"\"repetition of item within vector\"\"\"\ndef greater(a: Integer, b: Integer) -> Boolean:\n    \"\"\"greater\"\"\"\ndef size(container: Container) -> Integer:\n    \"\"\"cardinality\"\"\"\ndef merge(containers: ContainerContainer) -> Container:\n    \"\"\"merging\"\"\"\ndef maximum(container: IntegerSet) -> Integer:\n    \"\"\"maximum\"\"\"\ndef minimum(container: IntegerSet) -> Integer:\n    \"\"\"minimum\"\"\"\ndef valmax(container: Container, compfunc: Callable) -> Integer:\n    \"\"\"maximum by custom function\"\"\"\ndef valmin(container: Container, compfunc: Callable) -> Integer:\n    \"\"\"minimum by custom function\"\"\"\ndef argmax(container: Container, compfunc: Callable) -> Any:\n    \"\"\"largest item by custom order\"\"\"\ndef argmin(container: Container, compfunc: Callable) -> Any:\n    \"\"\"smallest item by custom order\"\"\"\ndef mostcommon(container: Container) -> Any:\n    \"\"\"most common item\"\"\"\ndef leastcommon(container: Container) -> Any:\n    \"\"\"least common item\"\"\"\ndef initset(value: Any) -> FrozenSet:\n    \"\"\"initialize container\"\"\"\ndef both(a: Boolean, b: Boolean) -> Boolean:\n    \"\"\"logical and\"\"\"\ndef either(a: Boolean, b: Boolean) -> Boolean:\n    \"\"\"logical or\"\"\"\ndef increment(x: Numerical) -> Numerical:\n    \"\"\"incrementing\"\"\"\ndef decrement(x: Numerical) -> Numerical:\n    \"\"\"decrementing\"\"\"\ndef crement(x: Numerical) -> Numerical:\n    \"\"\"incrementing positive and decrementing negative\"\"\"\ndef sign(x: Numerical) -> Numerical:\n    \"\"\"sign\"\"\"\ndef positive(x: Integer) -> Boolean:\n    \"\"\"positive\"\"\"\ndef toivec(i: Integer) -> IntegerTuple:\n    \"\"\"vector pointing vertically\"\"\"\ndef tojvec(j: Integer) -> IntegerTuple:\n    \"\"\"vector pointing horizontally\"\"\"\ndef sfilter(container: Container, condition: Callable) -> Container:\n    \"\"\"keep elements in container that satisfy condition\"\"\"\ndef mfilter(container: Container, function: Callable) -> FrozenSet:\n    \"\"\"filter and merge\"\"\"\ndef extract(container: Container, condition: Callable) -> Any:\n    \"\"\"first element of container that satisfies condition\"\"\"\ndef totuple(container: FrozenSet) -> Tuple:\n    \"\"\"conversion to tuple\"\"\"\ndef first(container: Container) -> Any:\n    \"\"\"first item of container\"\"\"\ndef last(container: Container) -> Any:\n    \"\"\"last item of container\"\"\"\ndef insert(value: Any, container: FrozenSet) -> FrozenSet:\n    \"\"\"insert item into container\"\"\"\ndef remove(value: Any, container: Container) -> Container:\n    \"\"\"remove item from container\"\"\"\ndef other(container: Container, value: Any) -> Any:\n    \"\"\"other value in the container\"\"\"\ndef interval(start: Integer, stop: Integer, step: Integer) -> Tuple:\n    \"\"\"range\"\"\"\ndef astuple(a: Integer, b: Integer) -> IntegerTuple:\n    \"\"\"constructs a tuple\"\"\"\ndef product(a: Container, b: Container) -> FrozenSet:\n    \"\"\"cartesian product\"\"\"\ndef pair(a: Tuple, b: Tuple) -> TupleTuple:\n    \"\"\"zipping of two tuples\"\"\"\ndef branch(condition: Boolean, a: Any, b: Any) -> Any:\n    \"\"\"if else branching\"\"\"\ndef compose(outer: Callable, inner: Callable) -> Callable:\n    \"\"\"function composition\"\"\"\ndef chain(h: Callable, g: Callable, f: Callable) -> Callable:\n    \"\"\"function composition with three functions\"\"\"\ndef matcher(function: Callable, target: Any) -> Callable:\n    \"\"\"construction of equality function\"\"\"\ndef rbind(function: Callable, fixed: Any) -> Callable:\n    \"\"\"fix the rightmost argument\"\"\"\ndef lbind(function: Callable, fixed: Any) -> Callable:\n    \"\"\"fix the leftmost argument\"\"\"\ndef power(function: Callable, n: Integer) -> Callable:\n    \"\"\"power of function\"\"\"\ndef fork(outer: Callable, a: Callable, b: Callable) -> Callable:\n    \"\"\"creates a wrapper function\"\"\"\ndef apply(function: Callable, container: Container) -> Container:\n    \"\"\"apply function to each item in container\"\"\"\ndef rapply(functions: Container, value: Any) -> Container:\n    \"\"\"apply each function in container to value\"\"\"\ndef mapply(function: Callable, container: ContainerContainer) -> FrozenSet:\n    \"\"\"apply and merge\"\"\"\ndef papply(function: Callable, a: Tuple, b: Tuple) -> Tuple:\n    \"\"\"apply function on two vectors\"\"\"\ndef mpapply(function: Callable, a: Tuple, b: Tuple) -> Tuple:\n    \"\"\"apply function on two vectors and merge\"\"\"\ndef prapply(function, a: Container, b: Container) -> FrozenSet:\n    \"\"\"apply function on cartesian product\"\"\"\ndef mostcolor(element: Element) -> Integer:\n    \"\"\"most common color\"\"\"\ndef leastcolor(element: Element) -> Integer:\n    \"\"\"least common color\"\"\"\ndef height(piece: Piece) -> Integer:\n    \"\"\"height of grid or patch\"\"\"\ndef width(piece: Piece) -> Integer:\n    \"\"\"width of grid or patch\"\"\"\ndef shape(piece: Piece) -> IntegerTuple:\n    \"\"\"height and width of grid or patch\"\"\"\ndef portrait(piece: Piece) -> Boolean:\n    \"\"\"whether height is greater than width\"\"\"\ndef colorcount(element: Element, value: Integer) -> Integer:\n    \"\"\"number of cells with color\"\"\"\ndef colorfilter(objs: Objects, value: Integer) -> Objects:\n    \"\"\"filter objects by color\"\"\"\ndef sizefilter(container: Container, n: Integer) -> FrozenSet:\n    \"\"\"filter items by size\"\"\"\ndef asindices(grid: Grid) -> Indices:\n    \"\"\"indices of all grid cells\"\"\"\ndef ofcolor(grid: Grid, value: Integer) -> Indices:\n    \"\"\"indices of all grid cells with value\"\"\"\ndef ulcorner(patch: Patch) -> IntegerTuple:\n    \"\"\"index of upper left corner\"\"\"\ndef urcorner(patch: Patch) -> IntegerTuple:\n    \"\"\"index of upper right corner\"\"\"\ndef llcorner(patch: Patch) -> IntegerTuple:\n    \"\"\"index of lower left corner\"\"\"\ndef lrcorner(patch: Patch) -> IntegerTuple:\n    \"\"\"index of lower right corner\"\"\"\ndef crop(grid: Grid, start: IntegerTuple, dims: IntegerTuple) -> Grid:\n    \"\"\"subgrid specified by start and dimension\"\"\"\ndef toindices(patch: Patch) -> Indices:\n    \"\"\"indices of object cells\"\"\"\ndef recolor(value: Integer, patch: Patch) -> Object:\n    \"\"\"recolor patch\"\"\"\ndef shift(patch: Patch, directions: IntegerTuple) -> Patch:\n    \"\"\"shift patch\"\"\"\ndef normalize(patch: Patch) -> Patch:\n    \"\"\"moves upper left corner to origin\"\"\"\ndef dneighbors(loc: IntegerTuple) -> Indices:\n    \"\"\"directly adjacent indices\"\"\"\ndef ineighbors(loc: IntegerTuple) -> Indices:\n    \"\"\"diagonally adjacent indices\"\"\"\ndef neighbors(loc: IntegerTuple) -> Indices:\n    \"\"\"adjacent indices\"\"\"\ndef objects(grid: Grid, univalued: Boolean, diagonal: Boolean, without_bg: Boolean) -> Objects:\n    \"\"\"objects occurring on the grid\"\"\"\ndef partition(grid: Grid) -> Objects:\n    \"\"\"each cell with the same value part of the same object\"\"\"\ndef fgpartition(grid: Grid) -> Objects:\n    \"\"\"each cell with the same value part of the same object without background\"\"\"\ndef uppermost(patch: Patch) -> Integer:\n    \"\"\"row index of uppermost occupied cell\"\"\"\ndef lowermost(patch: Patch) -> Integer:\n    \"\"\"row index of lowermost occupied cell\"\"\"\ndef leftmost(patch: Patch) -> Integer:\n    \"\"\"column index of leftmost occupied cell\"\"\"\ndef rightmost(patch: Patch) -> Integer:\n    \"\"\"column index of rightmost occupied cell\"\"\"\ndef square(piece: Piece) -> Boolean:\n    \"\"\"whether the piece forms a square\"\"\"\ndef vline(patch: Patch) -> Boolean:\n    \"\"\"whether the piece forms a vertical line\"\"\"\ndef hline(patch: Patch) -> Boolean:\n    \"\"\"whether the piece forms a horizontal line\"\"\"\ndef hmatching(a: Patch, b: Patch) -> Boolean:\n    \"\"\"whether there exists a row for which both patches have cells\"\"\"\ndef vmatching(a: Patch, b: Patch) -> Boolean:\n    \"\"\"whether there exists a column for which both patches have cells\"\"\"\ndef manhattan(a: Patch, b: Patch) -> Integer:\n    \"\"\"closest manhattan distance between two patches\"\"\"\ndef adjacent(a: Patch, b: Patch) -> Boolean:\n    \"\"\"whether two patches are adjacent\"\"\"\ndef bordering(patch: Patch, grid: Grid) -> Boolean:\n    \"\"\"whether a patch is adjacent to a grid border\"\"\"\ndef centerofmass(patch: Patch) -> IntegerTuple:\n    \"\"\"center of mass\"\"\"\ndef palette(element: Element) -> IntegerSet:\n    \"\"\"colors occurring in object or grid\"\"\"\ndef numcolors(element: Element) -> IntegerSet:\n    \"\"\"number of colors occurring in object or grid\"\"\"\ndef color(obj: Object) -> Integer:\n    \"\"\"color of object\"\"\"\ndef toobject(patch: Patch, grid: Grid) -> Object:\n    \"\"\"object from patch and grid\"\"\"\ndef asobject(grid: Grid) -> Object:\n    \"\"\"conversion of grid to object\"\"\"\ndef rot90(grid: Grid) -> Grid:\n    \"\"\"quarter clockwise rotation\"\"\"\ndef rot180(grid: Grid) -> Grid:\n    \"\"\"half rotation\"\"\"\ndef rot270(grid: Grid) -> Grid:\n    \"\"\"quarter anticlockwise rotation\"\"\"\ndef hmirror(piece: Piece) -> Piece:\n    \"\"\"mirroring along horizontal\"\"\"\ndef vmirror(piece: Piece) -> Piece:\n    \"\"\"mirroring along vertical\"\"\"\ndef dmirror(piece: Piece) -> Piece:\n    \"\"\"mirroring along diagonal\"\"\"\ndef cmirror(piece: Piece) -> Piece:\n    \"\"\"mirroring along counterdiagonal\"\"\"\ndef fill(grid: Grid, value: Integer, patch: Patch) -> Grid:\n    \"\"\"fill value at indices\"\"\"\ndef paint(grid: Grid, obj: Object) -> Grid:\n    \"\"\"paint object to grid\"\"\"\ndef underfill(grid: Grid, value: Integer, patch: Patch) -> Grid:\n    \"\"\"fill value at indices that are background\"\"\"\ndef underpaint(grid: Grid, obj: Object) -> Grid:\n    \"\"\"paint object to grid where there is background\"\"\"\ndef hupscale(grid: Grid, factor: Integer) -> Grid:\n    \"\"\"upscale grid horizontally\"\"\"\ndef vupscale(grid: Grid, factor: Integer) -> Grid:\n    \"\"\"upscale grid vertically\"\"\"\ndef upscale(element: Element, factor: Integer) -> Element:\n    \"\"\"upscale object or grid\"\"\"\ndef downscale(grid: Grid, factor: Integer) -> Grid:\n    \"\"\"downscale grid\"\"\"\ndef hconcat(a: Grid, b: Grid) -> Grid:\n    \"\"\"concatenate two grids horizontally\"\"\"\ndef vconcat(a: Grid, b: Grid) -> Grid:\n    \"\"\"concatenate two grids vertically\"\"\"\ndef subgrid(patch: Patch, grid: Grid) -> Grid:\n    \"\"\"smallest subgrid containing object\"\"\"\ndef hsplit(grid: Grid, n: Integer) -> Tuple:\n    \"\"\"split grid horizontally\"\"\"\ndef vsplit(grid: Grid, n: Integer) -> Tuple:\n    \"\"\"split grid vertically\"\"\"\ndef cellwise(a: Grid, b: Grid, fallback: Integer) -> Grid:\n    \"\"\"cellwise match of two grids\"\"\"\ndef replace(grid: Grid, replacee: Integer, replacer: Integer) -> Grid:\n    \"\"\"color substitution\"\"\"\ndef switch(grid: Grid, a: Integer, b: Integer) -> Grid:\n    \"\"\"color switching\"\"\"\ndef center(patch: Patch) -> IntegerTuple:\n    \"\"\"center of the patch\"\"\"\ndef position(a: Patch, b: Patch) -> IntegerTuple:\n    \"\"\"relative position between two patches\"\"\"\ndef index(grid: Grid, loc: IntegerTuple) -> Integer:\n    \"\"\"color at location\"\"\"\ndef canvas(value: Integer, dimensions: IntegerTuple) -> Grid:\n    \"\"\"grid construction\"\"\"\ndef corners(patch: Patch) -> Indices:\n    \"\"\"indices of corners\"\"\"\ndef connect(a: IntegerTuple, b: IntegerTuple) -> Indices:\n    \"\"\"line between two points\"\"\"\ndef cover(grid: Grid, patch: Patch) -> Grid:\n    \"\"\"remove object from grid\"\"\"\ndef trim(grid: Grid) -> Grid:\n    \"\"\"trim border of grid\"\"\"\ndef move(grid: Grid, obj: Object, offset: IntegerTuple) -> Grid:\n    \"\"\"move object on grid\"\"\"\ndef tophalf(grid: Grid) -> Grid:\n    \"\"\"upper half of grid\"\"\"\ndef bottomhalf(grid: Grid) -> Grid:\n    \"\"\"lower half of grid\"\"\"\ndef lefthalf(grid: Grid) -> Grid:\n    \"\"\"left half of grid\"\"\"\ndef righthalf(grid: Grid) -> Grid:\n    \"\"\"right half of grid\"\"\"\ndef vfrontier(location: IntegerTuple) -> Indices:\n    \"\"\"vertical frontier\"\"\"\ndef hfrontier(location: IntegerTuple) -> Indices:\n    \"\"\"horizontal frontier\"\"\"\ndef backdrop(patch: Patch) -> Indices:\n    \"\"\"indices in bounding box of patch\"\"\"\ndef delta(patch: Patch) -> Indices:\n    \"\"\"indices in bounding box but not part of patch\"\"\"\ndef gravitate(source: Patch, destination: Patch) -> IntegerTuple:\n    \"\"\"direction to move source until adjacent to destination\"\"\"\ndef inbox(patch: Patch) -> Indices:\n    \"\"\"inbox for patch\"\"\"\ndef outbox(patch: Patch) -> Indices:\n    \"\"\"outbox for patch\"\"\"\ndef box(patch: Patch) -> Indices:\n    \"\"\"outline of patch\"\"\"\ndef shoot(start: IntegerTuple, direction: IntegerTuple) -> Indices:\n    \"\"\"line from starting point and direction\"\"\"\ndef occurrences(grid: Grid, obj: Object) -> Indices:\n    \"\"\"locations of occurrences of object in grid\"\"\"\ndef frontiers(grid: Grid) -> Objects:\n    \"\"\"set of frontiers\"\"\"\ndef compress(grid: Grid) -> Grid:\n    \"\"\"removes frontiers from grid\"\"\"\ndef hperiod(obj: Object) -> Integer:\n    \"\"\"horizontal periodicity\"\"\"\ndef vperiod(obj: Object) -> Integer:\n    \"\"\"vertical periodicity\"\"\"\n```\n\n<example>\nInput 1\n\n\t|A|B|C|D|E|F|G|H|I|J\n1\t0|0|0|0|9|0|0|0|0|0\n2\t0|0|0|0|0|0|0|0|0|0\n3\t0|0|0|0|0|0|0|0|0|0\n4\t0|0|0|0|8|8|0|0|0|0\n5\t0|0|0|0|8|8|0|0|0|0\n6\t0|0|0|0|8|8|0|0|0|0\n7\t6|0|0|0|8|8|0|0|0|0\n8\t0|0|0|0|0|0|0|0|0|0\n9\t0|0|0|0|0|0|0|0|0|0\n10\t0|0|0|0|0|4|0|0|0|0\n\nOutput 1\n\n\t|A|B|C|D|E|F|G|H|I|J\n1\t0|0|0|0|9|0|0|0|0|0\n2\t0|0|0|0|0|0|0|0|0|0\n3\t0|0|0|0|0|0|0|0|0|0\n4\t0|0|0|0|9|8|0|0|0|0\n5\t0|0|0|0|8|8|0|0|0|0\n6\t0|0|0|0|8|8|0|0|0|0\n7\t6|0|0|0|6|4|0|0|0|0\n8\t0|0|0|0|0|0|0|0|0|0\n9\t0|0|0|0|0|0|0|0|0|0\n10\t0|0|0|0|0|4|0|0|0|0\n\nDiff 1 (I->O)\n\n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |8 -> 9|  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |8 -> 6|8 -> 4|  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n\nInput 2\n\n\t|A|B|C|D|E|F|G|H|I|J\n1\t0|0|0|0|7|0|0|0|0|0\n2\t0|0|0|0|0|0|0|0|0|0\n3\t0|0|0|0|0|0|0|0|0|0\n4\t6|0|0|8|8|8|0|0|0|0\n5\t0|0|0|8|8|8|0|0|0|0\n6\t0|0|0|8|8|8|0|0|0|2\n7\t0|0|0|8|8|8|0|0|0|0\n8\t3|0|0|8|8|8|0|0|0|0\n9\t0|0|0|0|0|0|0|0|0|0\n10\t0|0|0|0|0|1|0|0|0|0\n\nOutput 2\n\n\t|A|B|C|D|E|F|G|H|I|J\n1\t0|0|0|0|7|0|0|0|0|0\n2\t0|0|0|0|0|0|0|0|0|0\n3\t0|0|0|0|0|0|0|0|0|0\n4\t6|0|0|6|7|8|0|0|0|0\n5\t0|0|0|8|8|8|0|0|0|0\n6\t0|0|0|8|8|2|0|0|0|2\n7\t0|0|0|8|8|8|0|0|0|0\n8\t3|0|0|3|8|1|0|0|0|0\n9\t0|0|0|0|0|0|0|0|0|0\n10\t0|0|0|0|0|1|0|0|0|0\n\nDiff 2 (I->O)\n\n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |8 -> 6|8 -> 7|  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |8 -> 2|  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |8 -> 3|  --  |8 -> 1|  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n\nInput 3\n\n\t|A|B|C|D|E|F|G|H|I|J\n1\t0|0|0|4|0|0|0|0|0|0\n2\t0|0|0|0|0|0|0|0|0|0\n3\t0|0|0|0|0|0|0|0|0|0\n4\t0|0|0|8|8|8|0|0|0|6\n5\t3|0|0|8|8|8|0|0|0|0\n6\t0|0|0|8|8|8|0|0|0|0\n7\t2|0|0|8|8|8|0|0|0|0\n8\t0|0|0|8|8|8|0|0|0|2\n9\t0|0|0|0|0|0|0|0|0|0\n10\t0|0|0|7|0|0|0|0|0|0\n\nOutput 3\n\n\t|A|B|C|D|E|F|G|H|I|J\n1\t0|0|0|4|0|0|0|0|0|0\n2\t0|0|0|0|0|0|0|0|0|0\n3\t0|0|0|0|0|0|0|0|0|0\n4\t0|0|0|4|8|6|0|0|0|6\n5\t3|0|0|3|8|8|0|0|0|0\n6\t0|0|0|8|8|8|0|0|0|0\n7\t2|0|0|2|8|8|0|0|0|0\n8\t0|0|0|7|8|2|0|0|0|2\n9\t0|0|0|0|0|0|0|0|0|0\n10\t0|0|0|7|0|0|0|0|0|0\n\nDiff 3 (I->O)\n\n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |8 -> 4|  --  |8 -> 6|  --  |  --  |  --  |  --  \n  --  |  --  |  --  |8 -> 3|  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |8 -> 2|  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |8 -> 7|  --  |8 -> 2|  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n\nInput 1\n\n\t|A|B|C|D|E|F|G|H|I|J\n1\t0|0|0|6|0|2|0|0|0|0\n2\t0|0|0|0|0|0|0|0|0|0\n3\t0|0|0|0|0|0|0|0|0|0\n4\t9|0|8|8|8|8|0|0|0|0\n5\t0|0|8|8|8|8|0|0|0|7\n6\t3|0|8|8|8|8|0|0|0|0\n7\t4|0|8|8|8|8|0|0|0|0\n8\t0|0|0|0|0|0|0|0|0|0\n9\t0|0|0|0|0|0|0|0|0|0\n10\t0|0|0|0|6|0|0|0|0|0\n\nOutput 1\n\n\t|A|B|C|D|E|F|G|H|I|J\n1\t0|0|0|6|0|2|0|0|0|0\n2\t0|0|0|0|0|0|0|0|0|0\n3\t0|0|0|0|0|0|0|0|0|0\n4\t9|0|9|6|8|2|0|0|0|0\n5\t0|0|8|8|8|7|0|0|0|7\n6\t3|0|3|8|8|8|0|0|0|0\n7\t4|0|4|8|6|8|0|0|0|0\n8\t0|0|0|0|0|0|0|0|0|0\n9\t0|0|0|0|0|0|0|0|0|0\n10\t0|0|0|0|6|0|0|0|0|0\n\nDiff 1 (I->O)\n\n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |8 -> 9|8 -> 6|  --  |8 -> 2|  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |8 -> 7|  --  |  --  |  --  |  --  \n  --  |  --  |8 -> 3|  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |8 -> 4|  --  |8 -> 6|  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n\n\n<think>\nOutputs maintain input shape, with targeted edits. Let's look for visual patterns:\n\nDiff 1:\n- Brown (9) replaces purple (8) at top left of rectangle\n- Pink (6) replaces purple at bottom left\n- Yellow (4) replaces purple at bottom right\n\nInput 1:\n- Central purple rectangle\n- Brown cell above the new brown position\n- Pink cell left of new pink position\n- Yellow cell below new yellow position\n- Each source cell aligns with its target position\n\nDiff 2:\n- Orange (7) replaces purple at top\n- Pink replaces purple at top left\n- Red (2) replaces purple at middle right\n- Green (3) replaces purple at bottom left\n- Blue (1) replaces purple at bottom right\n\nInput 2:\n- Central purple rectangle\n- Each colored cell aligns with its target position (same row/column)\n\nDiff 3:\n- Yellow replaces purple at top left\n- Pink replaces purple at top right\n- Red replaces purple on left side\n- Orange replaces purple at bottom left\n- Red replaces purple at bottom right\n- Green replaces purple on left side\n\nAdditional example input:\n- Purple rectangle center\n- Colored cells around rectangle\n\nTransformation rule:\n1. Locate central purple rectangle\n2. Identify surrounding colored cells\n3. Replace purple edge cells with matching colors\n4. Vertical alignment: replace top/bottom cells\n5. Horizontal alignment: replace left/right cells\n\n### Alternative 1: Direct Copy\nMaybe each colored cell just directly copies its value to a specific position in the purple rectangle without any \"gravity\" logic.\n\nIf this were true, we would expect the same colored cell to always replace the same relative position in the rectangle. However, we see that cell positions matter - a cell at the top replaces the top edge, etc. So simple copying isn't the mechanism.\n\n### Alternative 2: Numerical Logic\nMaybe the transformation is based on numerical relationships between the values, not spatial relationships.\n\nThere's no consistent arithmetic relationship between the original values and their replacements. For example, the number 9 replaces 8, 6 replaces 8, 4 replaces 8, etc. The pattern is based on position, not numerical values.\n\n### Alternative 3: Distance-Based Replacement\nWait, maybe the closest colored cell to each purple cell determines its replacement.\nBut in several cases, there are purple cells that are closer to a colored cell than the one that gets replaced. The replacement appears to follow strict row/column alignment, not just proximity.\n\n### Alternative 4: Random Replacement\nWait, there's a random element to which cells get replaced.\nNo, the pattern is consistent across examples - edge cells get replaced based on alignment with colored cells. This is too consistent to be random.\n\n### Alternative 5: Color-Based Priority\nWait, maybe certain colors have priority in replacing purple cells.\nDifferent colors replace purple cells in different examples, and the same color replaces different positions in different examples. The positioning appears to be the determining factor, not the color value itself.\n\n## Alterative 6: Gravitational Color\nMaybe single colored cells affect the purple rectangle by replacing cells that align with them, either horizontally or vertically. \n\nIn each example:\n1. There's a central rectangle of purple (8) cells\n2. There are colored single cells scattered around the grid\n3. In the output, some of the purple cells on the edges of the rectangle are replaced with colors that match nearby single cells\n\nThe proposed transformation seems to be:\n1. Find the central purple rectangle (8s)\n2. Identify single colored cells around it\n3. Replace purple edge cells with matching colors based on some gravitational or directional logic\n \nLet's prove this by exhaustion against every example with an output.\n\nExample 1:\n- 9 at E1 replaces 8 at E4 (vertical alignment)\n- 6 at A7 replaces 8 at E7 (horizontal alignment)\n- 4 at F10 replaces 8 at F7 (vertical alignment)\n\nExample 2:\n- 7 at E1 replaces 8 at E4 (vertical alignment)\n- 6 at A4 replaces 8 at D4 (horizontal alignment)\n- 2 at J6 replaces 8 at F6 (horizontal alignment)\n- 3 at A8 replaces 8 at D8 (horizontal alignment)\n- 1 at F10 replaces 8 at F8 (vertical alignment)\n\nExample 3:\n- 4 at D1 replaces 8 at D4 (vertical alignment)\n- 6 at J4 replaces 8 at F4 (horizontal alignment)\n- 3 at A5 replaces 8 at D5 (horizontal alignment)\n- 2 at A7 replaces 8 at D7 (horizontal alignment)\n- 7 at D10 replaces 8 at D8 (vertical alignment)\n- 2 at J8 replaces 8 at F8 (horizontal alignment)\n\nYes, my proposed rule seems to hold across the examples. Let me solve this in the DSL. The user asked me to assume all DSL primitives are in scope, so I will reavoid redefining the functions. \n</think>\n\n```py\ndef solve(I):\n    x1 = objects(I, T, F, T)          # Find all distinct grid objects\n    x2 = sizefilter(x1, ONE)          # Get single-cell objects only\n    x3 = difference(x1, x2)           # Isolate purple rectangle object\n    x4 = first(x3)                    # Extract purple rectangle\n    x5 = rbind(gravitate, x4)         # Bind rectangle to gravitate\n    x6 = compose(crement, x5)         # Movement direction from gravity\n    x7 = fork(shift, identity, x6)    # Combine shift with original properties\n    x8 = mapply(x7, x2)              # Transform all single cells\n    O = paint(I, x8)                  # Paint transformed cells onto grid\n    return O\n```\n</example>\n\n\nNow reason to find the common pattern, following all original instructions.\n# Your Puzzle\n\n## EXAMPLES\nInput 1\n\n\t|A|B|C|D|E|F|G|H|I|J|K\n1\t0|0|0|0|0|0|0|0|0|0|0\n2\t1|0|0|0|0|0|0|0|0|0|2\n3\t0|0|0|0|0|0|0|0|0|0|0\n4\t0|0|0|0|0|0|0|0|0|0|0\n5\t0|0|0|0|0|0|0|0|0|0|0\n\nOutput 1\n\n\t|A|B|C|D|E|F|G|H|I|J|K\n1\t0|0|0|0|0|0|0|0|0|0|0\n2\t1|1|1|1|1|5|2|2|2|2|2\n3\t0|0|0|0|0|0|0|0|0|0|0\n4\t0|0|0|0|0|0|0|0|0|0|0\n5\t0|0|0|0|0|0|0|0|0|0|0\n\nDiff 1 (I->O)\n\n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |0 -> 1|0 -> 1|0 -> 1|0 -> 1|0 -> 5|0 -> 2|0 -> 2|0 -> 2|0 -> 2|  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n\nInput 2\n\n\t|A|B|C|D|E|F|G|H|I|J|K\n1\t0|0|0|0|0|0|0|0|0|0|0\n2\t0|0|0|0|0|0|0|0|0|0|0\n3\t0|0|0|0|0|0|0|0|0|0|0\n4\t3|0|0|0|0|0|0|0|0|0|7\n5\t0|0|0|0|0|0|0|0|0|0|0\n\nOutput 2\n\n\t|A|B|C|D|E|F|G|H|I|J|K\n1\t0|0|0|0|0|0|0|0|0|0|0\n2\t0|0|0|0|0|0|0|0|0|0|0\n3\t0|0|0|0|0|0|0|0|0|0|0\n4\t3|3|3|3|3|5|7|7|7|7|7\n5\t0|0|0|0|0|0|0|0|0|0|0\n\nDiff 2 (I->O)\n\n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n  --  |0 -> 3|0 -> 3|0 -> 3|0 -> 3|0 -> 5|0 -> 7|0 -> 7|0 -> 7|0 -> 7|  --  \n  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  |  --  \n\n\n## TEST\nInput 1\n\n\t|A|B|C|D|E|F|G|H|I|J|K\n1\t0|0|0|0|0|0|0|0|0|0|0\n2\t4|0|0|0|0|0|0|0|0|0|8\n3\t0|0|0|0|0|0|0|0|0|0|0\n4\t0|0|0|0|0|0|0|0|0|0|0\n5\t6|0|0|0|0|0|0|0|0|0|9\n\n","role":"user"}],[{"role":"assistant","content":"Alright, I'm faced with this puzzle where I need to determine the transformation rule that turns the input grid into the output grid. Let's break it down step by step.\n\nFirst, I'll look at the examples provided to see if I can identify any patterns or rules that consistently apply.\n\nLooking at Input 1 and Output 1:\n- The input has a grid with mostly zeros except for a 1 at position A2 and a 2 at position J2.\n- The output changes this 1 to a 1 at A2, keeps the 2 at J2, and introduces new values around it. For example, E2 becomes 5, and G2, H2, I2 become 2 on the second row. Similar changes occur in other parts of the grid.\n\nLooking at Input 2 and Output 2:\n- The input has a 3 at D4 and a 7 at E4.\n- The output changes D4 to 3, keeps E4 as 7, and adds new values on the fourth row. For instance, A5 becomes 3, D5 becomes 7, and so on.\n\nLooking at Input 3 and Output 3:\n- The input has a 4 at D1, and the output changes D1 to 4, adding new values on the fourth row and other parts of the grid.\n\nFrom these observations, it seems that the transformation involves replacing certain cells with specific values based on their positions relative to a central rectangle of zeros (8s).\n\nHere's what I deduce:\n1. **Identify the Central Purple Rectangle**: The central rectangle of zeros (8s) remains unchanged. This serves as a reference point.\n2. **Locate Single-Colored Cells**: Outside the central rectangle, there are single-colored cells (e.g., 4, 6, 7, 9, etc.).\n3. **Replace Purple Edge Cells**: The zeros on the edge of the central rectangle are replaced with the values of the nearest single-colored cells. This replacement happens both vertically and horizontally.\n\nFor example:\n- In Input 1, the 1 at A2 replaces the zero on the top edge of the rectangle, and the 2 at J2 replaces a zero on the bottom edge.\n- In Input 3, the 4 at D1 replaces a zero on the left edge, and the 6 at A7 replaces a zero on the top edge.\n\nThis rule explains the consistent transformation observed in all examples.\n\nNow, to implement this rule in the provided Python DSL, I need to:\n1. Identify the central rectangle of zeros (8s).\n2. Locate all single-colored cells around this rectangle.\n3. For each edge cell of the rectangle, replace it with the value of the nearest single-colored cell, matching the position (top, bottom, left, right).\n\nSo, the transformation involves:\n- Keeping the central rectangle unchanged.\n- Using the single-colored cells to determine the new values for the surrounding zeros on the grid's edges.\n\nThis approach ensures that the transformation is consistent across all examples and maintains the integrity of the grid's structure.\n</think>\n\nTo solve this problem, we need to determine the transformation rule that converts the input grid to the output grid. The transformation involves replacing certain cells in the grid based on their positions relative to a central rectangle of zeros. \n\n### Approach\nThe approach to solving this problem involves the following steps:\n\n1. **Identify the Central Rectangle**: The central rectangle of zeros (represented by 8 in the input grid) remains unchanged in the output grid.\n\n2. **Locate Single-Colored Cells**: These are cells that have values other than 0, located outside the central rectangle.\n\n3. **Replace Purple Edge Cells**: Zeros on the edge of the central rectangle are replaced with the values of the nearest single-colored cells. The replacement depends on the position of the zero relative to the single-colored cell:\n   - Zeros at the top edge of the rectangle are replaced with topmost single-colored cells.\n   - Zeros at the bottom edge are replaced with bottommost single-colored cells.\n   - Zeros on the left edge are replaced with leftmost single-colored cells.\n   - Zeros on the right edge are replaced with rightmost single-colored cells.\n\n### Solution Code\n```python\ndef solve(I: Grid):\n    # Find all single-colored cells (not part of central rectangle)\n    single_cold_cells = [(o, v) for o in cells(I) if v != 9 or 8]\n    if not single_cold_cells:\n        return I  # No single-colored cells, return original grid\n    \n    # Identify central rectangle of zeros (8s)\n    central_rect = rectangle(cell for cell in Grid if cell.value == 8)\n    top_row, top_col = central_rect.top\n    bottom_row, bottom_col = central_rect.bottom\n    \n    # Find the nearest single-colored cell for top edge zeros\n    top_col_single = nearest(cell for cell in Grid if cell.value != 0 and cell.col == top_col, key=lambda x: abs(x.row - top_row))\n    top_val = top_col_single.value\n    \n    # Find the nearest single-colored cell for bottom edge zeros\n    bottom_col_single = nearest(cell for cell in Grid if cell.value != 0 and cell.col == bottom_col, key=lambda x: abs(x.row - bottom_row))\n    bottom_val = bottom_col_single.value\n    \n    # Find the nearest single-colored cell for left edge zeros\n    left_row_single = nearest(cell for cell in Grid if cell.value != 0 and cell.row == top_row, key=lambda x: abs(x.col - top_col))\n    left_val = left_row_single.value\n    \n    # Find the nearest single-colored cell for right edge zeros\n    right_row_single = nearest(cell for cell in Grid if cell.value != 0 and cell.row == bottom_row, key=lambda x: abs(x.col - bottom_col))\n    right_val = right_row_single.value\n    \n    # Replace the zeros on the edges with the found single-colored values\n    output_grid = grid(I)\n    for cell in Grid:\n        if cell in central_rect:\n            output_grid[cell] = I[cell]\n        elif cell.row == top_row and cell.col >= central_rect.col1 and cell.col <= central_rect.col2:\n            output_grid[cell] = top_val\n        elif cell.row == bottom_row and cell.col >= central_rect.col1 and cell.col <= central_rect.col2:\n            output_grid[cell] = bottom_val\n        elif cell.col == top_col and cell.row >= central_rect.row1 and cell.row <= central_rect.row2:\n            output_grid[cell] = left_val\n        elif cell.col == bottom_col and cell.row >= central_rect.row1 and cell.row <= central_rect.row2:\n            output_grid[cell] = right_val\n    \n    return output_grid\n```\n\n### Explanation\n1. **Identify Single-Colored Cells**: We first identify all cells with values other than 0 that are not part of the central rectangle. These cells are used to determine the replacements for zeros on the edges of the central rectangle.\n\n2. **Central Rectangle**: The central rectangle is defined by its top-left and bottom-right corners. We extract these coordinates to know the boundaries of the rectangle.\n\n3. **Replacement Logic**:\n   - **Top Edge Zeros**: Zeros on the top edge of the rectangle are replaced with the nearest single-colored cell's value, which is determined by finding the cell in the same column as the top edge and in the same column index range as the central rectangle.\n   - **Bottom Edge Zeros**: Similar to top edge zeros, but finds the nearest single-colored cell in the same column and within the bottom edge range.\n   - **Left and Right Edge Zeros**: These zeros are replaced with the nearest single-colored cells in their respective rows and columns.\n\nThis approach ensures that the transformation is consistent and follows the observed patterns in the examples."}],{"id":"29c11459","train":[[[[0,0,0,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,0,0,2],[0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,5,2,2,2,2,2],[0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0]]],[[[0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0],[3,0,0,0,0,0,0,0,0,0,7],[0,0,0,0,0,0,0,0,0,0,0]],[[0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0],[3,3,3,3,3,5,7,7,7,7,7],[0,0,0,0,0,0,0,0,0,0,0]]]],"test":[[[[0,0,0,0,0,0,0,0,0,0,0],[4,0,0,0,0,0,0,0,0,0,8],[0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0],[6,0,0,0,0,0,0,0,0,0,9]],[[0,0,0,0,0,0,0,0,0,0,0],[4,4,4,4,4,5,8,8,8,8,8],[0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0],[6,6,6,6,6,5,9,9,9,9,9]]]],"solver":"def solve(I):\n    x1 = lefthalf(I)\n    x2 = righthalf(I)\n    x3 = objects(x2, T, F, T)\n    x4 = objects(x1, T, F, T)\n    x5 = compose(hfrontier, center)\n    x6 = fork(recolor, color, x5)\n    x7 = mapply(x6, x4)\n    x8 = paint(x1, x7)\n    x9 = mapply(x6, x3)\n    x10 = paint(I, x9)\n    x11 = objects(x8, T, F, T)\n    x12 = apply(urcorner, x11)\n    x13 = shift(x12, RIGHT)\n    x14 = merge(x11)\n    x15 = paint(x10, x14)\n    O = fill(x15, FIVE, x13)\n    return O\n"},"def solve(I: Grid):\n    # Find all single-colored cells (not part of central rectangle)\n    single_cold_cells = [(o, v) for o in cells(I) if v != 9 or 8]\n    if not single_cold_cells:\n        return I  # No single-colored cells, return original grid\n    \n    # Identify central rectangle of zeros (8s)\n    central_rect = rectangle(cell for cell in Grid if cell.value == 8)\n    top_row, top_col = central_rect.top\n    bottom_row, bottom_col = central_rect.bottom\n    \n    # Find the nearest single-colored cell for top edge zeros\n    top_col_single = nearest(cell for cell in Grid if cell.value != 0 and cell.col == top_col, key=lambda x: abs(x.row - top_row))\n    top_val = top_col_single.value\n    \n    # Find the nearest single-colored cell for bottom edge zeros\n    bottom_col_single = nearest(cell for cell in Grid if cell.value != 0 and cell.col == bottom_col, key=lambda x: abs(x.row - bottom_row))\n    bottom_val = bottom_col_single.value\n    \n    # Find the nearest single-colored cell for left edge zeros\n    left_row_single = nearest(cell for cell in Grid if cell.value != 0 and cell.row == top_row, key=lambda x: abs(x.col - top_col))\n    left_val = left_row_single.value\n    \n    # Find the nearest single-colored cell for right edge zeros\n    right_row_single = nearest(cell for cell in Grid if cell.value != 0 and cell.row == bottom_row, key=lambda x: abs(x.col - bottom_col))\n    right_val = right_row_single.value\n    \n    # Replace the zeros on the edges with the found single-colored values\n    output_grid = grid(I)\n    for cell in Grid:\n        if cell in central_rect:\n            output_grid[cell] = I[cell]\n        elif cell.row == top_row and cell.col >= central_rect.col1 and cell.col <= central_rect.col2:\n            output_grid[cell] = top_val\n        elif cell.row == bottom_row and cell.col >= central_rect.col1 and cell.col <= central_rect.col2:\n            output_grid[cell] = bottom_val\n        elif cell.col == top_col and cell.row >= central_rect.row1 and cell.row <= central_rect.row2:\n            output_grid[cell] = left_val\n        elif cell.col == bottom_col and cell.row >= central_rect.row1 and cell.row <= central_rect.row2:\n            output_grid[cell] = right_val\n    \n    return output_grid"]